~~~
    Advanced nekonomicon script demonstrating flow control, file operations, and arrays
    This script processes log files, analyzes patterns, and generates reports
    This is to teach Advanced developers.
~~~

import cabinet.

~ Initialize configuration
'./logs' into @log_directory.
'./processed' into @output_directory.
3 into @max_retries.
1000 into @max_file_size_mb.

~ Create output directory if needed
cabinet create directory @output_directory
  with silence
  on linux.

~ Setup initial state variables
0 into @files_processed.
0 into @errors_found.
0 into @warnings_found.
true into @processing_enabled.

say 'Starting log analysis system...'.

~ Get list of log files
cabinet list files @log_directory
  with extension '.log'
  with recursive
  into ::log_files.

~ Check if we have any files to process
decide ::log_files:count > 0 into @has_files.
decide @processing_enabled equals 'true' into @system_ready.
decide @max_retries > 0 into @retries_available.

if all @has_files @system_ready @retries_available
  say 'System ready for processing. Found @{::log_files:count} log files.'.
else
  if none @has_files @system_ready @retries_available
    error 'Complete system failure: no files, system not ready, and no retries available.'.
  else if @has_files
    error 'Files available but system not ready for processing.'.
  else
    error 'System ready but no log files found in @{log_directory}.'.
  end
  
  failure.
end

~ Main processing loop - continue while files exist and system is operational
while all @processing_enabled @system_ready
  ~ Process each log file
  foreach from ::log_files into @current_file
    say 'Processing file: @{current_file}'.
    
    ~ Check file size before processing
    cabinet get file size @current_file into @file_size_mb.
    decide @file_size_mb <= @max_file_size_mb into @size_ok.
    cabinet check file exists @current_file into @file_exists.
    cabinet check file readable @current_file into @file_readable.
    
    if all @size_ok @file_exists @file_readable
      ~ Read and process file content
      cabinet read file @current_file into @content.
      
      ~ Count different log levels
      text count pattern 'ERROR' in @content into @error_count.
      text count pattern 'WARN' in @content into @warning_count.
      text count pattern 'INFO' in @content into @info_count.
      
      ~ Update totals
      calculate @errors_found + @error_count into @errors_found.
      calculate @warnings_found + @warning_count into @warnings_found.
      calculate @files_processed + 1 into @files_processed.
      
      ~ Determine severity level
      decide @error_count > 10 into @high_errors.
      decide @warning_count > 50 into @high_warnings.
      decide @error_count equals 0 into @no_errors.
      
      if @high_errors
        say 'HIGH SEVERITY: @{current_file} has @{error_count} errors!'.
        'critical' into @severity.
      else if @high_warnings
        say 'MEDIUM SEVERITY: @{current_file} has @{warning_count} warnings.'.
        'warning' into @severity.
      else if @no_errors
        say 'CLEAN: @{current_file} has no errors.'.
        'clean' into @severity.
      else
        say 'LOW SEVERITY: @{current_file} has minor issues.'.
        'minor' into @severity.
      end
      
      ~ Generate report for this file
      text format 'File: @{current_file}\nSeverity: @{severity}\nErrors: @{error_count}\nWarnings: @{warning_count}\nInfo: @{info_count}\n---\n' into @file_report.
      
      ~ Append to summary report
      text extract filename from @current_file into @filename.
      text format '@{output_directory}/@{filename}.report' into @report_path.
      cabinet write file @report_path 
        with content @file_report
        with append
        with silence.
        
    else
      ~ Handle file processing errors
      if none @size_ok @file_exists @file_readable
        say 'SKIP: @{current_file} - file issues (size: @{file_size_mb}MB, exists: @{file_exists}, readable: @{file_readable})'.
      else if @size_ok
        say 'SKIP: @{current_file} - file too large (@{file_size_mb}MB > @{max_file_size_mb}MB limit)'.
      else
        say 'SKIP: @{current_file} - file access issues.'.
      end
      
      calculate @max_retries - 1 into @max_retries.
      decide @max_retries > 0 into @retries_available.
      
      if none @retries_available
        say 'Maximum retries exceeded. Disabling processing.'.
        'false' into @processing_enabled.
      end
    end
    
    ~ Check if we should continue processing
    decide @processing_enabled equals 'true' into @should_continue.
    decide @files_processed < 100 into @under_limit.
    
    if none @should_continue @under_limit
      say 'Stopping processing: system disabled or file limit reached.'.
      break.
    end
  end
  
  ~ Update system status after processing batch
  decide @processing_enabled equals 'true' into @still_enabled.
  decide ::log_files:count > @files_processed into @more_files.
  
  if none @still_enabled @more_files
    'false' into @processing_enabled.
    say 'Processing complete: no more files or system disabled.'.
  end
end

~ Generate final summary report
text format 'LOG ANALYSIS SUMMARY\n===================\nFiles Processed: @{files_processed}\nTotal Errors: @{errors_found}\nTotal Warnings: @{warnings_found}\nRetries Remaining: @{max_retries}\n' into @summary_report.

cabinet write file '@{output_directory}/summary.txt' 
  with content @summary_report
  with trace.

~ Final status check
decide @errors_found > 0 into @has_errors.
decide @files_processed > 0 into @processed_something.

if any @has_errors @processed_something
  if @has_errors
    say 'COMPLETED WITH ISSUES: Found @{errors_found} errors across @{files_processed} files.'.
    partial 'Log analysis completed with errors detected.'.
  else
    say 'COMPLETED SUCCESSFULLY: Processed @{files_processed} files with no errors.'.
    success 'Log analysis completed successfully.'.
  end
else
  say 'NO PROCESSING OCCURRED: No files were successfully processed.'.
  failure 'Log analysis failed - no files processed.'.
end